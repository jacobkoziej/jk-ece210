% SPDX-License-Identifier: CC-BY-NC-SA-4.0
%
% 02-vectorization.tex -- writing performant MATLAB code
% Copyright (C) 2024  Jacob Koziej <jacobkoziej@gmail.com>

\documentclass{article}

\input{preamble}
\title{Lesson 02: Vectorization}
\input{postamble}

\begin{document}
\renderTitle

So far, what we've learned hasn't been all that useful.  Sure, we can
instantiate matrices, but we're here to make MATLAB work like a horse.
One of the fundamental principles behind \emph{clean \& efficient} code
is the vectorization of operations.  By vectorizing, our code appears
more like mathematical expressions found in textbooks, introduces fewer
opportunities for errors, and runs much faster as it can utilize
hardware vector operations!\footurl{https://www.mathworks.com/help/%
matlab/matlab_prog/vectorization.html}

\section{Vector Generation}

Say we want to create a vector \(\mat{x} = (i : i \in \Z_8)\).  We could
do it like so:

\mCommandOutput{02-vectorization.d/basic-vector}

We achieved the following result by utilizing the \mCommand[https://www%
.mathworks.com/help/matlab/ref/colon.html]{:} operator.  This operator
is useful for generating vectors, which we can use either for
calculations or indexing into arrays.

The operator also allows us to specify a step increment other than one:

\mCommandOutput{02-vectorization.d/step-vector}

But what if we want to create a vector over some range with a fixed
amount of points (i.e. four evenly spaced values for \(t \in [0, 1]\))?
We could instead utilize \mCommand[https://www.mathworks.com/help/%
matlab/ref/linspace.html]{linspace()}:

\mCommandOutput{02-vectorization.d/linspace}
\end{document}
