% SPDX-License-Identifier: CC-BY-NC-SA-4.0
%
% 02-vectorization.tex -- writing performant MATLAB code
% Copyright (C) 2024  Jacob Koziej <jacobkoziej@gmail.com>

\documentclass{article}

\input{preamble}
\title{Lesson 02: Vectorization}
\input{postamble}

\begin{document}
\renderTitle

So far, what we've learned hasn't been all that useful.  Sure, we can
instantiate matrices, but we're here to make MATLAB work like a horse.
One of the fundamental principles behind \emph{clean \& efficient} code
is the vectorization of operations.  By vectorizing, our code appears
more like mathematical expressions found in textbooks, introduces fewer
opportunities for errors, and runs much faster as it can utilize
hardware vector operations!\footurl{https://www.mathworks.com/help/%
matlab/matlab_prog/vectorization.html}

\section{Vector Generation}

Say we want to create a vector \(\mat{x} = (i : i \in \Z_8)\).  We could
do it like so:

\mCommandOutput{02-vectorization.d/basic-vector}

We achieved the following result by utilizing the \mCommand[https://www%
.mathworks.com/help/matlab/ref/colon.html]{:} operator.  This operator
is useful for generating vectors, which we can use either for
calculations or indexing into arrays.

The operator also allows us to specify a step increment other than one:

\mCommandOutput{02-vectorization.d/step-vector}

But what if we want to create a vector over some range with a fixed
amount of points (i.e. four evenly spaced values for \(t \in [0, 1]\))?
We could instead utilize \mCommand[https://www.mathworks.com/help/%
matlab/ref/linspace.html]{linspace()}:

\mCommandOutput{02-vectorization.d/linspace}

\section{Indexing}

Now, to \emph{ruin} your day.  MATLAB starts indexing at one...

Let's reuse \(\mat{x}\) from the previous section.  We can access the
third element of \(\mat{x}\) like so:

\mCommandOutput{02-vectorization.d/third-element}

We can also access multiple elements at once:

\mCommandOutput{02-vectorization.d/multiple-elements}

Or if we're so inclined, the penultimate element:

\mCommandOutput{02-vectorization.d/penultimate-element}

Matrices logically follow by adding another index:

\mCommandOutput{02-vectorization.d/matrix-index}

\begin{minipage}{\textwidth}
	We can also index \emph{linearly:}

	\vspace{1em}

	\mCommandOutput{02-vectorization.d/linear-index}
\end{minipage}

But that's an adventure for another time \texttt{;)}

\section{Size \& Shape}

When dealing with N-dimensional arrays, it's important to know how to
get basic information related to the size and shape.  Lucky for us,
MATLAB offers a few convenient functions just for this!

\begin{itemize}
	\item
		\mCommand[https://www.mathworks.com/help/matlab/ref/%
		length.html]{length()} --- the length of the largest
		array dimension

	\item
		\mCommand[https://www.mathworks.com/help/matlab/ref/%
		size.html]{size()} --- the size of the array

	\item
		\mCommand[https://www.mathworks.com/help/matlab/ref/%
		ndims.html]{ndims()} --- the number of array dimensions

	\item
		\mCommand[https://www.mathworks.com/help/matlab/ref/%
		numel.html]{numel()} --- the number of array elements
\end{itemize}
\end{document}
