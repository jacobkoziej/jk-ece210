% SPDX-License-Identifier: CC-BY-NC-SA-4.0
%
% 03-indexing.tex -- getting what you want
% Copyright (C) 2024  Jacob Koziej <jacobkoziej@gmail.com>

\documentclass{article}

\input{preamble}
\title{Lesson 03: Indexing}
\input{postamble}

\begin{document}
\renderTitle

At first, indexing in MATLAB seems like a trivial topic, and for the
most part, the basics will suffice for most \emph{basic} operations.
However, once you start trying to vectorize more complicated operations,
especially ones that rely on conditions, you'll quickly find yourself
limited in what you can calculate.

\section{Subscript Indexing}

For the remainder of this lesson, we'll be working with the following:
\begin{equation}
	\mat{x}
	=
	[1, 2, 3, 4, 5, 6, 7, 8]
\end{equation}
\begin{equation}
	\mat{A}
	=
	\begin{bmatrix}
		1 & 5 &  9 & 13 \\
		2 & 6 & 10 & 14 \\
		3 & 7 & 11 & 15 \\
		4 & 8 & 12 & 16 \\
	\end{bmatrix}
\end{equation}

We've already seen that we can access multiple elements of a vector by
indexing with another vector:

\mCommandOutput{03-indexing.d/seen}

But we can also write to these elements:

\mCommandOutput{03-indexing.d/write}

Matrices behave much the same as this behavior extends to each
dimension:

\mCommandOutput{03-indexing.d/matrix}

Say we want to select all elements of a dimension; we can use a bare
\mCommand{:} in place of \mCommand{1:end} to save us some typing:

\mCommandOutput{03-indexing.d/col}

\section{Linear Indexing}

Last lesson, we flirted with the idea of linear indexing without getting
too much into how it works.  Essentially, MATLAB stores its arrays in
column-major order,  and linear indexing is nothing more than taking
advantage of this design decision.

Take for example:

\mCommandOutput{03-indexing.d/linear}

You might find yourself having to convert between subscripts and linear
indices depending on what you're trying to achieve, and for that MATLAB
has the \mCommand[https://www.mathworks.com/help/matlab/ref/sub2ind.%
html]{sub2ind()} and \mCommand[https://www.mathworks.com/help/matlab/%
ref/ind2sub.html]{ind2sub()} functions.

As the names may suggest, they return return one indexing regime given
the other.  The only requirement for these functions is the size of the
array you're working with:

\mCommandOutput{03-indexing.d/ind2sub}

\mCommandOutput{03-indexing.d/sub2ind}

\section{Logical Arrays}

We've finally reached the point where we can introduce a new datatype:
the \emph{logical} datatype.  MATLAB logical values operate over
\(\Z_2\) where \mCommand{0} denotes \mCommand[https://www.mathworks.%
com/help/matlab/ref/false.html]{false}, and \mCommand{1} denotes
\mCommand[https://www.mathworks.com/help/matlab/ref/true.html]{true}.

What makes logical arrays so powerful is that they obey the rules of
Boolean Algebra and allow for us to extract elements of arrays.

\begin{longtable}{p{0.15\textwidth}p{0.65\textwidth}}
\toprule
Operator & Purpose \\
\midrule
\mCommand{&}   & Logical AND                                         \\
\mCommand{&&}  & Logical AND with short-circuiting                   \\
\mCommand{~}   & Logical NOT                                         \\
\mCommand{|}   & Logical OR                                          \\
\mCommand{||}  & Logical OR with short-circuiting                    \\
\mCommand{xor} & Logical exclusive-OR                                \\
\mCommand{all} & Determine if all array elements are nonzero or true \\
\mCommand{any} & Determine if any array elements are nonzero         \\
\bottomrule
\\
\caption{Logical Operations}
\end{longtable}

Say we wanted to extract the corners of \(\mat{A}\).  We could create a
logical array with \mCommand[https://www.mathworks.com/help/matlab/ref/%
logical.html]{logical()} with \(1\)'s in the location of the elements
we'd like to extract:

\inputminted{matlab}{03-indexing.d/corners.m}

\begin{minipage}{\textwidth}
	We can then use this logical array to index into \(\mat{A}\):

	\vspace{1em}

	\mCommandOutput{03-indexing.d/select}
\end{minipage}
\end{document}
